---
title: "The Great Migration: From MkDocs-Material to Nextra 4 with a Python Helper"
---

# Escaping the Static: Why I Moved from MkDocs-Material (and How)

Let me start by saying: I genuinely love MkDocs-Material. It's been a fantastic tool for building documentation sites, including a large educational platform I run with over 200 pages of blockchain tutorials and code samples. It's simple, powerful for static content, and the Material theme looks great.

But... my ambitions grew. I started dreaming of interactive code examples, wallet connections, community features, maybe even some slick animations. The kind of dynamic functionality that pushes the boundaries of a static site generator. Sure, I could hack my way through with MkDocs overrides, but it felt like patching holes in a dam that was about to burst. It was time for a change.

Enter Next.js and, specifically, Nextra 4. It felt like the polished, React-powered future I was looking for. Dynamic capabilities? Check. Great developer experience? Check. But there was one *massive* hurdle: migration.

Nextra isn't a drop-in replacement. It has its own conventions, its own way of handling routing (file-based), and while it understands Markdown (thanks to MDX), it doesn't natively speak the delightful MkDocs-Material dialect of admonitions (`!!! note`), tabs (`=== "Title"`), and other custom syntax I relied on heavily.

Staring at 200+ pages, the thought of manually converting everything – restructuring folders, rewriting syntax, fixing image paths, ensuring hundreds of redirects didn't break – was daunting. It felt like weeks, maybe months, of tedious, error-prone work. There had to be a better way.

## Automating the Exodus: The Birth of a Migration Script

When faced with a repetitive, complex task, what does a developer do? Automate it!

I decided to build a bridge. A Python script designed specifically to translate the structure and nuances of an MkDocs-Material site into something Nextra could understand. It wouldn't be perfect, but it could handle the heavy lifting, saving countless hours of manual labor.

This script became my secret weapon for the migration. It tackles the core challenges: understanding the `mkdocs.yml` navigation, replicating the structure in Nextra's `app` directory, converting common MkDocs syntax to React components, copying images, and, crucially, generating redirect rules to preserve SEO and user experience.

Here's the script itself:

```python

#!/usr/bin/env python3
import yaml
import os
import shutil
import re
import json
from pathlib import Path

# --- Configuration ---
MKDOCS_FILE = 'mkdocs.yml'
SOURCE_DOCS_DIR = './docs' # Directory containing mkdocs.yml and source .md files/folders
DEST_APP_DIR = 'app'
IMAGE_ALT_TEXT = "ethereum-blockchain-developer-image" # Default alt text
# --- End Configuration ---

def sanitize_slug(name):
    """Converts a title or filename into a URL/filesystem-friendly slug."""
    if not name: # Handle empty or None names
        return ""
    name = str(name).lower()
    name = re.sub(r'\s+', '-', name) # Replace spaces with hyphens
    name = re.sub(r'[^\w\-.]', '', name) # Remove invalid chars
    name = re.sub(r'\.md$', '', name) # Remove .md extension
    # Handle potential empty strings after sanitization if the original was just invalid chars
    if not name:
        # Maybe generate a random short string or use a counter?
        # For now, let's return something predictable but maybe not ideal.
        return "invalid-title-slug"
    return name

def format_meta_value(value):
    """Formats a Python value into a JS/TS object literal value."""
    if isinstance(value, str):
        if '`' in value or '\n' in value:
             escaped_value = value.replace('`', '\\`')
             return f"`{escaped_value}`"
        else:
             escaped_value = value.replace("\"", "\\\"")
             return f'"{escaped_value}"'
    elif isinstance(value, bool):
        return str(value).lower()
    elif isinstance(value, (int, float)):
        return str(value)
    elif isinstance(value, dict):
        return format_meta_object(value)
    elif isinstance(value, list):
        return f"[{', '.join(format_meta_value(v) for v in value)}]"
    elif value is None:
        return 'null'
    else:
        return f'"{str(value)}"'

def format_meta_object(data, indent=1):
    """Formats a Python dict into a JS/TS object literal string."""
    if not data:
        return "{}"

    indent_str = "    " * indent
    prev_indent_str = "    " * (indent - 1)
    items = []
    for key, value in data.items():
        formatted_key = f'"{key}"' # Always quote keys for safety
        formatted_value = format_meta_value(value)

        if isinstance(value, dict):
             formatted_value = format_meta_object(value, indent + 1)

        items.append(f"{indent_str}{formatted_key}: {formatted_value}")

    return f"{{\n{',\n'.join(items)}\n{prev_indent_str}}}"

# --- New Content Processing Logic ---

def process_inline_and_html(segment, source_md_path, source_docs_dir, mdx_path, html_to_react_attrs):
    """
    Processes images, links, <br>, HTML attributes, and escapes '<' within a text segment,
    avoiding code fences (```...```).
    """
    processed_parts = []
    # Split by code fences (```), keeping the delimiters
    # Using re.split with a capturing group keeps the delimiters in the list
    parts = re.split(r'(```[\s\S]*?```)', segment)

    for i, part in enumerate(parts):
        # If the index is odd, it's content *inside* a code fence
        if i % 2 == 1:
            processed_parts.append(part) # Keep code block content as is
            continue

        # If the index is even, it's content *outside* a code fence
        # Apply processing only to these parts
        processed_part = part
        if not processed_part: # Skip empty parts that can result from split
            continue

        # Default alt text (can be overridden by config)
        IMAGE_ALT_TEXT = "ethereum-blockchain-developer-image"

        # --- Image Processing ---
        img_processed_segment = ""
        img_last_index = 0
        image_regex = re.compile(r'(!{1,2})\[(.*?)\]\((.*?)\)(?:\s*\{[^}]*?\})?')

        for match in image_regex.finditer(processed_part):
            start, end = match.span()
            img_processed_segment += processed_part[img_last_index:start]

            original_alt = match.group(2)
            img_path = match.group(3).strip()
            alt_text = original_alt if original_alt else IMAGE_ALT_TEXT

            # Ensure path is relative for Nextra (prefix with ./) unless it's absolute or web
            if not img_path.startswith(('./', '../', '/')) and not img_path.startswith('http'):
                 img_path_relative_to_mdx = f"./{img_path}"
            else:
                 img_path_relative_to_mdx = img_path

            new_tag = f'![{alt_text}]({img_path_relative_to_mdx})'
            img_processed_segment += new_tag
            img_last_index = end

            # --- Copy Image File ---
            if not img_path.startswith('http'): # Don't copy web images
                source_img_path = Path(source_docs_dir) / Path(os.path.dirname(source_md_path)) / img_path
                dest_img_path = (Path(os.path.dirname(mdx_path)) / Path(img_path)).resolve()
                dest_img_dir = dest_img_path.parent

                try:
                    dest_img_dir.mkdir(parents=True, exist_ok=True)
                    source_img_path_abs = source_img_path.resolve()
                    if source_img_path_abs.is_file():
                        shutil.copy2(source_img_path_abs, dest_img_path)
                    else:
                        source_img_path_alt = (Path(source_docs_dir) / img_path).resolve()
                        if source_img_path_alt.is_file():
                             shutil.copy2(source_img_path_alt, dest_img_path)
                        else:
                             print(f"      Warning: Source image not found: {source_img_path_abs} or {source_img_path_alt}")
                except Exception as e:
                    print(f"      Error copying image {source_img_path}: {e}")

        img_processed_segment += processed_part[img_last_index:]
        processed_part = img_processed_segment

        # --- Link and Angle Bracket Processing ---
        processed_part = re.sub(r'(\[.*?\]\(.*?\))(\{[^}]*?\})', r'\1', processed_part) # Remove {attrs} from links
        processed_part = re.sub(r'<(https?://[^>]+)>', r'\1', processed_part) # Convert <http...> to http...
        processed_part = re.sub(r'<br\s*/?>', '<br />\n', processed_part, flags=re.IGNORECASE) # Convert <br> to <br />

        # --- Selective '<' Escaping ---
        # Escape '<' if not followed by a letter, '/', '!', or '?'
        # This aims to preserve HTML/JSX tags and comments/directives.
        # Note: This might not perfectly handle all edge cases with inline code (`<... >`).
        processed_part = re.sub(r"<(?![a-zA-Z/?!])", "&lt;", processed_part)

        # --- HTML Attribute Conversion ---
        tag_regex = re.compile(r'<([a-zA-Z][a-zA-Z0-9]*)((?:\s+[a-zA-Z][a-zA-Z0-9-]*(?:=(?:"[^"]*"|\'[^\']*\'|[^\s>]*))?)*)\s*(/?)>', re.DOTALL)

        def convert_attributes_inline(match):
            tag_name = match.group(1)
            attrs_text = match.group(2)
            self_closing = match.group(3)

            # Skip conversion for known React components
            if tag_name in ['Admonition', 'Tabs', 'TabsList', 'TabsTrigger', 'TabsContent']:
                return match.group(0)

            if not attrs_text.strip():
                return match.group(0) # Return original tag if no attributes

            attr_regex = re.compile(r'\s+([a-zA-Z][a-zA-Z0-9-]*)(?:=(?:"([^"]*)"|\'([^\']*)\'|([^\s>]*)))?')
            new_attrs_text = ""
            last_attr_end = 0

            for attr_match in attr_regex.finditer(attrs_text):
                start, end = attr_match.span()
                new_attrs_text += attrs_text[last_attr_end:start]

                attr_name = attr_match.group(1)
                attr_value_double = attr_match.group(2)
                attr_value_single = attr_match.group(3)
                attr_value_unquoted = attr_match.group(4)

                attr_value = ""
                quote_char = '"'
                is_boolean = False
                if attr_value_double is not None:
                    attr_value = attr_value_double; quote_char = '"'
                elif attr_value_single is not None:
                    attr_value = attr_value_single; quote_char = "'"
                elif attr_value_unquoted is not None:
                    attr_value = attr_value_unquoted; quote_char = ''
                else:
                    is_boolean = True; quote_char = ''

                new_attr_name = attr_name
                new_attr_value = attr_value
                is_style = False

                if attr_name.lower() == 'style':
                    is_style = True
                    style_dict = {}
                    for style_decl in attr_value.split(';'):
                        if not style_decl.strip(): continue
                        parts = style_decl.split(':', 1)
                        if len(parts) == 2:
                            prop, val = parts[0].strip(), parts[1].strip()
                            if '-' in prop:
                                prop_parts = prop.split('-')
                                prop = prop_parts[0] + ''.join(p.capitalize() for p in prop_parts[1:])
                            style_dict[prop] = val
                    style_items = [f'"{k}": "{v.replace("\"", "\\\"")}"' for k, v in style_dict.items()]
                    style_obj_str = f"{{{', '.join(style_items)}}}"
                    new_attr_name = "style"
                    new_attr_value = f"{{{style_obj_str}}}"
                    quote_char = ''

                elif attr_name.lower() in html_to_react_attrs:
                    new_attr_name = html_to_react_attrs[attr_name.lower()]

                if is_boolean and not is_style:
                    new_attrs_text += f'{new_attr_name}'
                elif quote_char == '"':
                    escaped_val = new_attr_value.replace('"', '&quot;')
                    new_attrs_text += f'{new_attr_name}="{escaped_val}"'
                elif quote_char == "'":
                    escaped_val = new_attr_value.replace("'", '&apos;')
                    new_attrs_text += f"{new_attr_name}='{escaped_val}'"
                elif quote_char == '':
                    if is_style:
                        new_attrs_text += f'{new_attr_name}={new_attr_value}'
                    else:
                        escaped_val = new_attr_value.replace('"', '&quot;')
                        new_attrs_text += f'{new_attr_name}="{escaped_val}"'

                last_attr_end = end

            new_attrs_text += attrs_text[last_attr_end:]
            return f'<{tag_name} {new_attrs_text.strip()}{self_closing}>'

        processed_part = tag_regex.sub(convert_attributes_inline, processed_part)

        # Append the processed non-code part
        processed_parts.append(processed_part)

    # Rejoin all parts (code and processed non-code)
    return "".join(processed_parts)

# --- End New Content Processing Logic ---


def process_mdx_file(mdx_path, source_md_path, source_docs_dir):
    """
    Processes a single MDX file:
    - Converts MkDocs Admonitions to <Admonition> component.
    - Converts MkDocs Tabs (=== "Title") to <Tabs> component.
    - Processes content within and between blocks for images, links, HTML attributes.
    - Adds necessary imports.
    """
    print(f"  Processing: {mdx_path}")
    content = ""
    try:
        with open(mdx_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        print(f"    Error reading {mdx_path}: {e}")
        return

    admonition_import = "import {Admonition} from \"@/components/Admonition\";\n"
    tabs_import = "import { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\n"
    needs_admonition_import = False
    needs_tabs_import = False

    html_to_react_attrs = {
        'frameborder': 'frameBorder', 'allowfullscreen': 'allowFullScreen', 'tabindex': 'tabIndex',
        'readonly': 'readOnly', 'maxlength': 'maxLength', 'cellspacing': 'cellSpacing',
        'cellpadding': 'cellPadding', 'rowspan': 'rowSpan', 'colspan': 'colSpan',
        'crossorigin': 'crossOrigin', 'datetime': 'dateTime', 'for': 'htmlFor', 'class': 'className',
        'autocomplete': 'autoComplete', 'autofocus': 'autoFocus', 'enctype': 'encType',
        'formaction': 'formAction', 'hreflang': 'hrefLang', 'inputmode': 'inputMode',
        'srcdoc': 'srcDoc', 'srclang': 'srcLang', 'srcset': 'srcSet',
        'acceptcharset': 'acceptCharset', 'accesskey': 'accessKey',
        'contenteditable': 'contentEditable', 'contextmenu': 'contextMenu', 'spellcheck': 'spellCheck'
    }

    # Regex to find start of admonition (captures marker, type, optional title)
    admonition_regex = re.compile(r'^(!!!|\?\?\?|\+\+\+)\s+([a-zA-Z0-9_-]+)(?:\s+"([^"]*)")?\s*$', re.MULTILINE)
    # Regex to find start of a tab (captures title)
    tab_start_regex = re.compile(r'^=== \"(.*?)\"\s*$', re.MULTILINE)

    processed_content_parts = [] # Store processed parts (strings)
    lines = content.splitlines()
    line_idx = 0
    content_len = len(lines)

    while line_idx < content_len:
        line = lines[line_idx]
        admonition_match = admonition_regex.match(line)
        tab_match = tab_start_regex.match(line)

        # --- Handle Admonition Block ---
        if admonition_match:
            needs_admonition_import = True
            admonition_marker = admonition_match.group(1)
            admonition_type = admonition_match.group(2).lower()
            admonition_title = admonition_match.group(3) if admonition_match.group(3) is not None else admonition_type.capitalize()
            # Escape quotes in title for the attribute value
            escaped_title = admonition_title.replace('"', '\\"')

            body_lines = []
            line_idx += 1 # Move past header line
            while line_idx < content_len:
                current_line = lines[line_idx]
                indent_match = re.match(r'^( {4}|\t)', current_line)
                if indent_match or not current_line.strip(): # Indented or blank line
                    # Dedent if indented, otherwise keep as is (for blank lines)
                    dedented_line = current_line[len(indent_match.group(1)):] if indent_match else current_line
                    body_lines.append(dedented_line)
                    line_idx += 1
                else:
                    break # End of admonition block

            admonition_body = '\n'.join(body_lines)
            processed_body = process_inline_and_html(admonition_body, source_md_path, source_docs_dir, mdx_path, html_to_react_attrs)

            type_map = {
                "note": "note", "info": "info", "tip": "tip", "success": "success",
                "question": "question", "warning": "warning", "failure": "failure",
                "danger": "danger", "bug": "bug", "example": "example", "quote": "quote",
                "abstract": "abstract", "hint": "tip"
            }
            mapped_type = type_map.get(admonition_type, "note")

            admonition_component = f'<Admonition type="{mapped_type}" title="{escaped_title}">\n{processed_body}\n</Admonition>'
            processed_content_parts.append(admonition_component)

        # --- Handle Tab Block ---
        elif tab_match:
            needs_tabs_import = True
            tabs_data = []
            current_tab_title = tab_match.group(1)
            current_tab_lines = []
            line_idx += 1 # Move past the first === line

            while line_idx < content_len:
                current_line = lines[line_idx]
                next_tab_match = tab_start_regex.match(current_line)

                if next_tab_match:
                    # Finish previous tab
                    tabs_data.append({
                        'title': current_tab_title,
                        'raw_content': '\n'.join(current_tab_lines)
                    })
                    # Start new tab
                    current_tab_title = next_tab_match.group(1)
                    current_tab_lines = []
                    line_idx += 1
                else:
                    indent_match = re.match(r'^( {4}|\t)', current_line)
                    if indent_match or not current_line.strip(): # Indented or blank line
                        # Dedent if indented, otherwise keep as is (for blank lines)
                        dedented_line = current_line[len(indent_match.group(1)):] if indent_match else current_line
                        current_tab_lines.append(dedented_line)
                        line_idx += 1
                    else:
                        break # End of the entire tab block

            # Add the last tab's data
            tabs_data.append({
                'title': current_tab_title,
                'raw_content': '\n'.join(current_tab_lines)
            })

            if tabs_data:
                tabs_list_items = []
                tabs_content_items = []
                default_value = sanitize_slug(tabs_data[0]['title'])
                if not default_value: default_value = "tab-1" # Fallback default value

                for i, tab in enumerate(tabs_data):
                    title = tab['title']
                    raw_content = tab['raw_content']
                    value = sanitize_slug(title)
                    if not value: value = f"tab-{i+1}"

                    processed_tab_content = process_inline_and_html(raw_content, source_md_path, source_docs_dir, mdx_path, html_to_react_attrs)

                    # Title goes inside the trigger tag, value is the slug
                    tabs_list_items.append(f'<TabsTrigger value="{value}">{title}</TabsTrigger>')
                    tabs_content_items.append(f'<TabsContent value="{value}">\n{processed_tab_content}\n</TabsContent>')

                # Indent the generated JSX for readability
                tabs_list_str = "\n    ".join(tabs_list_items)
                tabs_content_str = "\n  ".join(tabs_content_items) # Indent content items less

                tabs_component = f'<Tabs defaultValue="{default_value}" className="w-full">\n' # Add class for width
                tabs_component += f'  <TabsList>\n    {tabs_list_str}\n  </TabsList>\n'
                tabs_component += f'  {tabs_content_str}\n'
                tabs_component += '</Tabs>'
                processed_content_parts.append(tabs_component)

        # --- Handle Regular Line / Text Segment ---
        else:
            text_segment_lines = []
            start_text_idx = line_idx
            while line_idx < content_len:
                 current_line = lines[line_idx]
                 # Check if the *current* line starts a block
                 if admonition_regex.match(current_line) or tab_start_regex.match(current_line):
                     break # Stop accumulating text
                 else:
                     text_segment_lines.append(current_line)
                     line_idx += 1

            if text_segment_lines:
                text_segment = '\n'.join(text_segment_lines)
                # Avoid processing empty segments which can happen with consecutive newlines
                if text_segment.strip():
                    processed_segment = process_inline_and_html(text_segment, source_md_path, source_docs_dir, mdx_path, html_to_react_attrs)
                    processed_content_parts.append(processed_segment)
            # If no text lines were collected but we didn't hit a block, it means we are at the end?
            # The outer loop condition `while line_idx < content_len` handles termination.

    # --- Final Assembly ---
    final_output_parts = []
    added_imports = set()

    # Check original content for existing imports before adding new ones
    has_existing_tabs_import = "from \"@/components/ui/tabs\"" in content or "from '@/components/ui/tabs'" in content
    has_existing_admonition_import = "from \"@/components/Admonition\"" in content or "from '@/components/Admonition'" in content

    if needs_tabs_import and not has_existing_tabs_import:
        import_str = tabs_import.strip()
        if import_str not in added_imports:
             final_output_parts.append(tabs_import)
             added_imports.add(import_str)
    if needs_admonition_import and not has_existing_admonition_import:
        import_str = admonition_import.strip()
        if import_str not in added_imports:
             final_output_parts.append(admonition_import)
             added_imports.add(import_str)

    if added_imports:
        final_output_parts.append("\n") # Add newline after imports

    # Join the processed parts, using double newline to separate blocks/segments
    final_output_parts.extend(processed_content_parts)
    # Filter out any potential None or empty strings from parts list before joining
    final_output = "\n\n".join(filter(None, final_output_parts)).strip() + "\n" # Ensure single trailing newline

    # Write processed content back to file
    try:
        with open(mdx_path, 'w', encoding='utf-8') as f:
            f.write(final_output)
    except Exception as e:
        print(f"    Error writing processed content to {mdx_path}: {e}")


def process_nav_item(item, current_path_parts, parent_meta_dict, source_docs_dir, dest_app_dir, redirect_rules):
    """
    Recursively processes a navigation item from mkdocs.yml.
    Generates page.mdx files, folder-specific _meta.tsx files, and collects redirect rules.
    """
    if isinstance(item, dict):
        # Should only be one key-value pair per dict item in nav
        title, value = list(item.items())[0]
        slug = sanitize_slug(title)
        if not slug: # Handle cases where title becomes empty slug
             print(f"  Warning: Skipping item with title '{title}' resulting in empty slug.")
             return

        if isinstance(value, str): # It's a page
            source_md_filename = value
            # Ensure source_md_path is relative to the SOURCE_DOCS_DIR base
            source_md_path = os.path.join(source_docs_dir, source_md_filename)
            # Destination folder path uses the slug
            dest_folder_path = os.path.join(dest_app_dir, *current_path_parts, slug)
            dest_mdx_path = os.path.join(dest_folder_path, 'page.mdx')

            print(f"Processing page: '{title}' -> {dest_folder_path}")

            if os.path.isfile(source_md_path):
                try:
                    os.makedirs(dest_folder_path, exist_ok=True)
                    # Copy first, then process the copy
                    shutil.copy2(source_md_path, dest_mdx_path)
                    # Pass the source filename relative to source_docs_dir for image path calculation
                    process_mdx_file(dest_mdx_path, source_md_filename, source_docs_dir)
                    parent_meta_dict[slug] = title

                    # --- Add Redirect Rule ---
                    source_path = '/' + source_md_filename.replace('.md', '')
                    # Ensure destination path parts are correctly joined
                    destination_path = '/' + '/'.join(current_path_parts + [slug])
                    redirect_rules.append({
                        'source': source_path,
                        'destination': destination_path,
                        'permanent': True
                    })
                    # --- End Add Redirect Rule ---

                except Exception as e:
                    print(f"  Error processing file {source_md_path}: {e}")
            else:
                print(f"  Warning: Source file not found: {source_md_path}")

        elif isinstance(value, list): # It's a sub-menu/folder
            print(f"Processing folder: '{title}' -> {os.path.join(dest_app_dir, *current_path_parts, slug)}")
            parent_meta_dict[slug] = title # Add folder entry to parent meta

            # Create meta dict for the *current* folder
            current_folder_meta = {}
            current_folder_dest_path = os.path.join(dest_app_dir, *current_path_parts, slug)
            current_meta_file_path = os.path.join(current_folder_dest_path, '_meta.tsx')
            new_path_parts = current_path_parts + [slug]

            # Ensure the destination folder exists before processing children or writing _meta.tsx
            os.makedirs(current_folder_dest_path, exist_ok=True)

            # Process children, passing the current_folder_meta and redirect_rules list
            for sub_item in value:
                process_nav_item(sub_item, new_path_parts, current_folder_meta, source_docs_dir, dest_app_dir, redirect_rules)

            # Write the _meta.tsx file for the current folder
            if current_folder_meta: # Only write if there are items
                meta_content = f"export default {format_meta_object(current_folder_meta, indent=1)}"
                try:
                    with open(current_meta_file_path, 'w', encoding='utf-8') as f:
                        f.write(meta_content)
                    print(f"  Generated meta file: {current_meta_file_path}")
                except Exception as e:
                    print(f"  Error writing meta file {current_meta_file_path}: {e}")

    elif isinstance(item, str): # Simple file entry (less common for structure)
        # Treat as a page
        source_md_filename = item
        # Generate title from filename if needed (could improve this)
        raw_title = Path(item).stem.replace('-', ' ').replace('_', ' ').title()
        slug = sanitize_slug(raw_title) # Use sanitized title for slug
        if not slug:
             print(f"  Warning: Skipping item '{item}' resulting in empty slug.")
             return
        title = raw_title # Keep original-cased title for display

        source_md_path = os.path.join(source_docs_dir, source_md_filename)
        dest_folder_path = os.path.join(dest_app_dir, *current_path_parts, slug)
        dest_mdx_path = os.path.join(dest_folder_path, 'page.mdx')

        print(f"Processing page: '{title}' (from '{item}') -> {dest_folder_path}")

        if os.path.isfile(source_md_path):
            try:
                os.makedirs(dest_folder_path, exist_ok=True)
                shutil.copy2(source_md_path, dest_mdx_path)
                # Pass the source filename relative to source_docs_dir
                process_mdx_file(dest_mdx_path, source_md_filename, source_docs_dir)
                # Add entry to the parent's meta dictionary
                parent_meta_dict[slug] = title

                # --- Add Redirect Rule ---
                source_path = '/' + source_md_filename.replace('.md', '')
                # Ensure destination path parts are correctly joined
                destination_path = '/' + '/'.join(current_path_parts + [slug])
                redirect_rules.append({
                    'source': source_path,
                    'destination': destination_path,
                    'permanent': True
                })
                # --- End Add Redirect Rule ---

            except Exception as e:
                print(f"  Error processing file {source_md_path}: {e}")
        else:
            print(f"  Warning: Source file not found: {source_md_path}")

def main():
    """Main execution function."""
    print("Starting MkDocs to Nextra migration...")

    # --- Load mkdocs.yml ---
    try:
        with open(MKDOCS_FILE, 'r', encoding='utf-8') as f:
            mkdocs_config = yaml.safe_load(f)
        print(f"Loaded '{MKDOCS_FILE}'")
    except FileNotFoundError:
        print(f"Error: '{MKDOCS_FILE}' not found in the current directory.")
        return
    except Exception as e:
        print(f"Error reading or parsing '{MKDOCS_FILE}': {e}")
        return

    nav_data = mkdocs_config.get('nav')
    if not nav_data:
        print("Error: 'nav' section not found in mkdocs.yml")
        return

    # --- Optional: Clean destination directory ---
    # Be careful enabling this!
    # if os.path.exists(DEST_APP_DIR):
    #     print(f"Cleaning destination directory: {DEST_APP_DIR}")
    #     # shutil.rmtree(DEST_APP_DIR)
    # os.makedirs(DEST_APP_DIR, exist_ok=True)

    # --- Process Navigation and Files ---
    top_level_meta = {}
    # Add the default index page (assuming you have an app/page.mdx or similar)
    # You might need to adjust this if your index isn't handled by mkdocs.yml
    top_level_meta['index'] = {
         'title': 'Home',
         'display': 'hidden' # Often hidden if it's just a landing page
    }
    # Add other top-level non-mkdocs pages if necessary, e.g.:
    # top_level_meta['other-page'] = 'Other Page Title'

    print("Processing navigation items and generating files...")
    redirect_rules = [] # Initialize list to store redirect rules

    # Process top-level items from mkdocs nav
    # The process_nav_item function will recursively handle sub-items
    # and generate _meta.tsx files in subdirectories, collecting redirects.
    for item in nav_data:
        process_nav_item(item, [], top_level_meta, SOURCE_DOCS_DIR, DEST_APP_DIR, redirect_rules)

    # --- Process existing redirects from mkdocs.yml ---
    print("Processing existing redirects from mkdocs.yml...")
    mkdocs_redirects = {}
    # Navigate safely through the config structure
    plugins = mkdocs_config.get('plugins', [])
    if isinstance(plugins, list):
        for plugin in plugins:
            if isinstance(plugin, dict) and 'redirects' in plugin:
                mkdocs_redirects = plugin['redirects'].get('redirect_maps', {})
                break
            elif isinstance(plugin, str) and plugin == 'redirects':
                # Handle case where plugin options might be elsewhere (less common)
                # This part might need adjustment based on actual mkdocs.yml structure if redirects aren't nested
                pass

    if mkdocs_redirects:
        for source, dest in mkdocs_redirects.items():
            # Basic normalization: add leading slash, remove .md
            source_path = '/' + source.replace('.md', '')
            dest_path = '/' + dest.replace('.md', '')
            # Avoid adding duplicates if source already handled by nav processing
            # Note: This simple check might not catch all nuances if paths differ slightly
            if not any(rule['source'] == source_path for rule in redirect_rules):
                 redirect_rules.append({
                     'source': source_path,
                     'destination': dest_path,
                     'permanent': True # Assume permanent for old redirects
                 })
                 print(f"  Added redirect map: {source_path} -> {dest_path}")
    else:
        print("  No 'redirect_maps' found in mkdocs.yml plugins configuration.")


    # --- Generate top-level app/_meta.tsx ---
    print("Generating top-level app/_meta.tsx...")
    meta_content = f"export default {format_meta_object(top_level_meta, indent=1)}"
    meta_file_path = os.path.join(DEST_APP_DIR, '_meta.tsx') # Note: _meta.tsx, not _meta.global.tsx

    try:
        os.makedirs(DEST_APP_DIR, exist_ok=True) # Ensure app dir exists before writing meta
        with open(meta_file_path, 'w', encoding='utf-8') as f:
            f.write(meta_content)
        print(f"Successfully generated '{meta_file_path}'")
    except Exception as e:
        print(f"Error writing '{meta_file_path}': {e}")

    # --- Generate redirects.ts file ---
    print("\nGenerating redirects.ts file...")
    redirects_file_path = 'redirects.ts'
    redirects_ts_content_parts = [
        "// Generated by migrate_mkdocs_to_nextra.py",
        "// Contains redirect rules from mkdocs.yml nav structure and explicit redirects.",
        "",
        "import type { Redirect } from 'next/dist/lib/load-custom-routes';",
        "",
        "export const migrationRedirects: Redirect[] = ["
    ]

    # Use json.dumps for proper escaping and formatting of each rule object
    for rule in redirect_rules:
        # Convert Python bool True to JS true
        rule_str = json.dumps(rule, indent=4).replace('true', 'true')
        redirects_ts_content_parts.append(rule_str + ",")

    redirects_ts_content_parts.append("];")
    redirects_ts_content = "\n".join(redirects_ts_content_parts)

    try:
        with open(redirects_file_path, 'w', encoding='utf-8') as f:
            f.write(redirects_ts_content)
        print(f"Successfully generated '{redirects_file_path}' with {len(redirect_rules)} rules.")
    except Exception as e:
        print(f"Error writing '{redirects_file_path}': {e}")


    print("\nMigration script finished.")
    print(f"Check the '{DEST_APP_DIR}' directory for generated files.")
    print("Review the generated MDX files for any formatting issues or needed manual adjustments, especially complex HTML/JSX.")

    # --- Instructions for next.config.ts ---
    print("\n--- Action Required: Update next.config.ts ---")
    print("To apply the generated redirects, modify your 'next.config.ts' file:")
    print("1. Import the generated redirects:")
    print("   import { migrationRedirects } from './redirects';")
    print("\n2. Add or modify the 'redirects' function in your NextConfig object:")
    print("""
    const nextConfig: NextConfig = {
      // ... other configurations
      async redirects() {
        // Combine generated redirects with any other custom redirects you might have
        const customRedirects = [
          // { source: '/some/other/path', destination: '/new/location', permanent: true },
        ];
        return [...migrationRedirects, ...customRedirects];
      },
      // ... rest of your config
    };
    """)
    print("-------------------------------------------------")

if __name__ == "__main__":
    # Check for PyYAML dependency
    try:
        import yaml
    except ImportError:
        print("Error: PyYAML is not installed.")
        print("Please install it using: pip install PyYAML")
        exit(1)
    main()

```

## How the Magic Happens: What the Script Does

So, what exactly does this Python script do? Think of it as a translator and architect rolled into one:

1.  **Reads Your Blueprint (`mkdocs.yml`):** It parses your `mkdocs.yml`, paying close attention to the `nav` section to understand your site's intended structure.
2.  **Builds the New Structure (`app/`):** Based on the `nav`, it creates the nested folder structure required by Nextra's file-based routing inside your target `app` directory.
3.  **Generates Navigation Metadata (`_meta.tsx`):** For each folder created, it generates a `_meta.tsx` file. This tells Nextra the order and display names for your sidebar navigation, mirroring your `mkdocs.yml` setup.
4.  **Moves and Converts Content (`.md` to `page.mdx`):** It finds the Markdown files (`.md`) referenced in your `nav`, copies them into the correct new folder, and renames them to `page.mdx`.
5.  **Translates MkDocs Syntax:** This is where the real heavy lifting happens:
    *   **Admonitions:** It finds MkDocs admonitions (`!!! note "Title"`, `??? question`, etc.) and converts them into JSX for a React component (e.g., `<Admonition type="note" title="Title">...</Admonition>`). You'll need to have a corresponding `Admonition` component in your Next.js project.
    *   **Tabs:** It detects MkDocs tabs (`=== "Tab Title"`) and transforms them into a structure suitable for a tab component library like Shadcn UI's Tabs (e.g., `<Tabs><TabsList><TabsTrigger>...</TabsTrigger></TabsList><TabsContent>...</TabsContent></Tabs>`). Again, you'll need the relevant components.
6.  **Handles Images:** It scans the Markdown content for image references (`![alt](./images/foo.png)`), copies the actual image files from your source `docs` directory to the new `app` subfolder alongside the `page.mdx` file, and updates the paths within the MDX to point to the new location.
7.  **Cleans Up HTML & Links:** It attempts to convert common HTML attributes to their React equivalents (e.g., `class` to `className`, `frameborder` to `frameBorder`, inline `style` strings to style objects). It also cleans up MkDocs-specific attribute lists on links and standardizes `<br>` tags.
8.  **Preserves Your History (Redirects):** It analyzes both the structure defined in `nav` and any explicit redirects defined in your `mkdocs.yml` (using the `redirects` plugin `redirect_maps`). It then generates a `redirects.ts` file containing a list of rules mapping the old MkDocs URLs to the new Nextra URLs. This is *crucial* for SEO and preventing broken links.

## Putting the Script to Work: How to Use It

Ready to give it a try? Here’s the quick guide:

1.  **Prerequisites:** Make sure you have Python 3 installed. You'll also need the PyYAML library:
    ```bash
    pip install PyYAML
    ```
2.  **Configuration:** Open the script (`migrate_mkdocs_to_nextra.py`) and adjust the configuration variables at the top to match your project:
    ```python
    # --- Configuration ---
    MKDOCS_FILE = 'mkdocs.yml' # Path to your mkdocs config
    SOURCE_DOCS_DIR = './docs' # Your MkDocs source content directory
    DEST_APP_DIR = 'app'       # Your Nextra app directory
    IMAGE_ALT_TEXT = "your-default-alt-text" # Default alt text if missing
    # --- End Configuration ---
    ```
3.  **Location:** Place the Python script in the root directory of your *MkDocs* project (where `mkdocs.yml` lives).
4.  **Run It:** Execute the script from your terminal in that directory:
    ```bash
    python migrate_mkdocs_to_nextra.py
    ```

The script will then work its magic, creating the new structure and files in the `DEST_APP_DIR` you specified, and generating the `redirects.ts` file in the root. Watch the console output for progress and any warnings.

## The Result: Your Content, Reborn in Nextra

After the script finishes, you'll find:

*   **A Nextra-ready `app/` directory:** Your content, organized according to Nextra's routing, with `.md` files converted to `page.mdx`.
*   **Navigation sorted (`_meta.tsx`):** Files in each directory defining the sidebar structure.
*   **Images relocated:** Image files copied and paths updated within your MDX.
*   **A `redirects.ts` file:** Ready to plug into your Next.js configuration.

**Important Next Steps (The Manual Polish):**

The script gets you 90% of the way there, but automation isn't magic. You'll need to:

1.  **Review the MDX:** Check the generated `page.mdx` files. Complex HTML, inline styles, or unusual Markdown might need manual tweaking to render correctly in React.
2.  **Implement Components:** Ensure you have the React components the script expects (`Admonition`, `Tabs`, etc.) available in your Next.js project (e.g., in `@/components/`) and that they accept the props the script generates.
3.  **Configure Redirects:** This is critical! Follow the instructions printed by the script (and repeated below) to integrate `redirects.ts` into your `next.config.ts` (or `.mjs`). This tells Next.js how to handle traffic going to the old URLs.
    *   Import the redirects: `import { migrationRedirects } from './redirects';`
    *   Add/modify the `redirects` function in `next.config.ts`:
        ```typescript
        const nextConfig = {
          // ... other config
          async redirects() {
            const customRedirects = [
              // Add any other redirects you need here
            ];
            return [...migrationRedirects, ...customRedirects];
          },
          // ... rest of config
        };
        ```
4.  **Test Everything:** Run your Next.js dev server (`npm run dev` or `yarn dev`) and click through your site. Check navigation, page rendering, component functionality, images, and test some old URLs to ensure redirects are working.

## Keeping it Real: Limitations

This script is a powerful helper, but it's not a silver bullet. Be aware of its limitations:

*   **Complex HTML/JS:** It does basic HTML attribute conversion, but intricate structures or embedded JavaScript in your Markdown will likely need manual conversion to JSX/React.
*   **Other MkDocs Plugins:** It's specifically designed for `admonition`, `pymdownx.tabbed`, and `redirects`. Content heavily reliant on other plugins might not translate well.
*   **Theme Features:** Anything specific to the MkDocs Material *theme* itself (beyond the handled syntax) won't be carried over.
*   **Slug Issues:** The slug generation is simple. Unusual titles leading to empty or duplicate slugs could cause problems.
*   **Internal Links:** It handles image paths but doesn't automatically rewrite internal Markdown links (e.g., `[link text](../category/other-page.md)`) to match Nextra's routing. You'll need to review and update these manually.

## Was It Worth It?

Absolutely. While not a fully automated push-button solution, this script turned a potentially months-long manual migration into a manageable task. It handled the most tedious parts, allowing me to focus on refining the content, building the necessary React components, and embracing the new possibilities offered by Nextra.

If you're facing a similar migration from MkDocs-Material to Nextra, I hope this script can serve as your bridge, saving you time and headaches on your journey to a more dynamic documentation platform.
