---
title: "Convert MkDocs-Material to Nextra 4"
---

A while ago I started this project as a drop-in replacement for MkDocs-Material.

I want to emphasize first: I love MkDos-Material.

However, my needs outgrew what the static page generator can offer.

I am running a relatively large scale educational site in the blockchain category with well over 200 code samples and tutorials using pretty much all that mkdocs-material has to offer. On top of that I wanted to have a community, interactive code samples, animations, be able to connect a wallet, etc etc. I could hack my way into mkdocs-material with overrides, but really... at some point you have to ask why.

But why Nextra 4?

Nextra 4 is somehow awesome. It's a polished version of my attempt to produce a docs page. However, its not an mkdocs-material drop-in replacement. It got nothing to do with MkDocs at all, sans Markdown files parsing. There is GFM but that's about it. MkDocs-Material has this spectacularly easy to use markdown syntax for admonitions and tabs and much more. I use that extensively on my site.


This Python script helps migrate content structured for MkDocs (specifically using the Material theme conventions and plugins like `admonition`, `pymdownx.tabbed`, and `redirects`) to a format suitable for Next.js with Nextra v4.

```python

#!/usr/bin/env python3
import yaml
import os
import shutil
import re
import json
from pathlib import Path

# --- Configuration ---
MKDOCS_FILE = 'mkdocs.yml'
SOURCE_DOCS_DIR = './docs' # Directory containing mkdocs.yml and source .md files/folders
DEST_APP_DIR = 'app'
IMAGE_ALT_TEXT = "ethereum-blockchain-developer-image" # Default alt text
# --- End Configuration ---

def sanitize_slug(name):
    """Converts a title or filename into a URL/filesystem-friendly slug."""
    if not name: # Handle empty or None names
        return ""
    name = str(name).lower()
    name = re.sub(r'\s+', '-', name) # Replace spaces with hyphens
    name = re.sub(r'[^\w\-.]', '', name) # Remove invalid chars
    name = re.sub(r'\.md$', '', name) # Remove .md extension
    # Handle potential empty strings after sanitization if the original was just invalid chars
    if not name:
        # Maybe generate a random short string or use a counter?
        # For now, let's return something predictable but maybe not ideal.
        return "invalid-title-slug"
    return name

def format_meta_value(value):
    """Formats a Python value into a JS/TS object literal value."""
    if isinstance(value, str):
        if '`' in value or '\n' in value:
             escaped_value = value.replace('`', '\\`')
             return f"`{escaped_value}`"
        else:
             escaped_value = value.replace("\"", "\\\"")
             return f'"{escaped_value}"'
    elif isinstance(value, bool):
        return str(value).lower()
    elif isinstance(value, (int, float)):
        return str(value)
    elif isinstance(value, dict):
        return format_meta_object(value)
    elif isinstance(value, list):
        return f"[{', '.join(format_meta_value(v) for v in value)}]"
    elif value is None:
        return 'null'
    else:
        return f'"{str(value)}"'

def format_meta_object(data, indent=1):
    """Formats a Python dict into a JS/TS object literal string."""
    if not data:
        return "{}"

    indent_str = "    " * indent
    prev_indent_str = "    " * (indent - 1)
    items = []
    for key, value in data.items():
        formatted_key = f'"{key}"' # Always quote keys for safety
        formatted_value = format_meta_value(value)

        if isinstance(value, dict):
             formatted_value = format_meta_object(value, indent + 1)

        items.append(f"{indent_str}{formatted_key}: {formatted_value}")

    return f"{{\n{',\n'.join(items)}\n{prev_indent_str}}}"

# --- New Content Processing Logic ---

def process_inline_and_html(segment, source_md_path, source_docs_dir, mdx_path, html_to_react_attrs):
    """
    Processes images, links, <br>, HTML attributes, and escapes '<' within a text segment,
    avoiding code fences (```...```).
    """
    processed_parts = []
    # Split by code fences (```), keeping the delimiters
    # Using re.split with a capturing group keeps the delimiters in the list
    parts = re.split(r'(```[\s\S]*?```)', segment)

    for i, part in enumerate(parts):
        # If the index is odd, it's content *inside* a code fence
        if i % 2 == 1:
            processed_parts.append(part) # Keep code block content as is
            continue

        # If the index is even, it's content *outside* a code fence
        # Apply processing only to these parts
        processed_part = part
        if not processed_part: # Skip empty parts that can result from split
            continue

        # Default alt text (can be overridden by config)
        IMAGE_ALT_TEXT = "ethereum-blockchain-developer-image"

        # --- Image Processing ---
        img_processed_segment = ""
        img_last_index = 0
        image_regex = re.compile(r'(!{1,2})\[(.*?)\]\((.*?)\)(?:\s*\{[^}]*?\})?')

        for match in image_regex.finditer(processed_part):
            start, end = match.span()
            img_processed_segment += processed_part[img_last_index:start]

            original_alt = match.group(2)
            img_path = match.group(3).strip()
            alt_text = original_alt if original_alt else IMAGE_ALT_TEXT

            # Ensure path is relative for Nextra (prefix with ./) unless it's absolute or web
            if not img_path.startswith(('./', '../', '/')) and not img_path.startswith('http'):
                 img_path_relative_to_mdx = f"./{img_path}"
            else:
                 img_path_relative_to_mdx = img_path

            new_tag = f'![{alt_text}]({img_path_relative_to_mdx})'
            img_processed_segment += new_tag
            img_last_index = end

            # --- Copy Image File ---
            if not img_path.startswith('http'): # Don't copy web images
                source_img_path = Path(source_docs_dir) / Path(os.path.dirname(source_md_path)) / img_path
                dest_img_path = (Path(os.path.dirname(mdx_path)) / Path(img_path)).resolve()
                dest_img_dir = dest_img_path.parent

                try:
                    dest_img_dir.mkdir(parents=True, exist_ok=True)
                    source_img_path_abs = source_img_path.resolve()
                    if source_img_path_abs.is_file():
                        shutil.copy2(source_img_path_abs, dest_img_path)
                    else:
                        source_img_path_alt = (Path(source_docs_dir) / img_path).resolve()
                        if source_img_path_alt.is_file():
                             shutil.copy2(source_img_path_alt, dest_img_path)
                        else:
                             print(f"      Warning: Source image not found: {source_img_path_abs} or {source_img_path_alt}")
                except Exception as e:
                    print(f"      Error copying image {source_img_path}: {e}")

        img_processed_segment += processed_part[img_last_index:]
        processed_part = img_processed_segment

        # --- Link and Angle Bracket Processing ---
        processed_part = re.sub(r'(\[.*?\]\(.*?\))(\{[^}]*?\})', r'\1', processed_part) # Remove {attrs} from links
        processed_part = re.sub(r'<(https?://[^>]+)>', r'\1', processed_part) # Convert <http...> to http...
        processed_part = re.sub(r'<br\s*/?>', '<br />\n', processed_part, flags=re.IGNORECASE) # Convert <br> to <br />

        # --- Selective '<' Escaping ---
        # Escape '<' if not followed by a letter, '/', '!', or '?'
        # This aims to preserve HTML/JSX tags and comments/directives.
        # Note: This might not perfectly handle all edge cases with inline code (`<... >`).
        processed_part = re.sub(r"<(?![a-zA-Z/?!])", "&lt;", processed_part)

        # --- HTML Attribute Conversion ---
        tag_regex = re.compile(r'<([a-zA-Z][a-zA-Z0-9]*)((?:\s+[a-zA-Z][a-zA-Z0-9-]*(?:=(?:"[^"]*"|\'[^\']*\'|[^\s>]*))?)*)\s*(/?)>', re.DOTALL)

        def convert_attributes_inline(match):
            tag_name = match.group(1)
            attrs_text = match.group(2)
            self_closing = match.group(3)

            # Skip conversion for known React components
            if tag_name in ['Admonition', 'Tabs', 'TabsList', 'TabsTrigger', 'TabsContent']:
                return match.group(0)

            if not attrs_text.strip():
                return match.group(0) # Return original tag if no attributes

            attr_regex = re.compile(r'\s+([a-zA-Z][a-zA-Z0-9-]*)(?:=(?:"([^"]*)"|\'([^\']*)\'|([^\s>]*)))?')
            new_attrs_text = ""
            last_attr_end = 0

            for attr_match in attr_regex.finditer(attrs_text):
                start, end = attr_match.span()
                new_attrs_text += attrs_text[last_attr_end:start]

                attr_name = attr_match.group(1)
                attr_value_double = attr_match.group(2)
                attr_value_single = attr_match.group(3)
                attr_value_unquoted = attr_match.group(4)

                attr_value = ""
                quote_char = '"'
                is_boolean = False
                if attr_value_double is not None:
                    attr_value = attr_value_double; quote_char = '"'
                elif attr_value_single is not None:
                    attr_value = attr_value_single; quote_char = "'"
                elif attr_value_unquoted is not None:
                    attr_value = attr_value_unquoted; quote_char = ''
                else:
                    is_boolean = True; quote_char = ''

                new_attr_name = attr_name
                new_attr_value = attr_value
                is_style = False

                if attr_name.lower() == 'style':
                    is_style = True
                    style_dict = {}
                    for style_decl in attr_value.split(';'):
                        if not style_decl.strip(): continue
                        parts = style_decl.split(':', 1)
                        if len(parts) == 2:
                            prop, val = parts[0].strip(), parts[1].strip()
                            if '-' in prop:
                                prop_parts = prop.split('-')
                                prop = prop_parts[0] + ''.join(p.capitalize() for p in prop_parts[1:])
                            style_dict[prop] = val
                    style_items = [f'"{k}": "{v.replace("\"", "\\\"")}"' for k, v in style_dict.items()]
                    style_obj_str = f"{{{', '.join(style_items)}}}"
                    new_attr_name = "style"
                    new_attr_value = f"{{{style_obj_str}}}"
                    quote_char = ''

                elif attr_name.lower() in html_to_react_attrs:
                    new_attr_name = html_to_react_attrs[attr_name.lower()]

                if is_boolean and not is_style:
                    new_attrs_text += f'{new_attr_name}'
                elif quote_char == '"':
                    escaped_val = new_attr_value.replace('"', '&quot;')
                    new_attrs_text += f'{new_attr_name}="{escaped_val}"'
                elif quote_char == "'":
                    escaped_val = new_attr_value.replace("'", '&apos;')
                    new_attrs_text += f"{new_attr_name}='{escaped_val}'"
                elif quote_char == '':
                    if is_style:
                        new_attrs_text += f'{new_attr_name}={new_attr_value}'
                    else:
                        escaped_val = new_attr_value.replace('"', '&quot;')
                        new_attrs_text += f'{new_attr_name}="{escaped_val}"'

                last_attr_end = end

            new_attrs_text += attrs_text[last_attr_end:]
            return f'<{tag_name} {new_attrs_text.strip()}{self_closing}>'

        processed_part = tag_regex.sub(convert_attributes_inline, processed_part)

        # Append the processed non-code part
        processed_parts.append(processed_part)

    # Rejoin all parts (code and processed non-code)
    return "".join(processed_parts)

# --- End New Content Processing Logic ---


def process_mdx_file(mdx_path, source_md_path, source_docs_dir):
    """
    Processes a single MDX file:
    - Converts MkDocs Admonitions to <Admonition> component.
    - Converts MkDocs Tabs (=== "Title") to <Tabs> component.
    - Processes content within and between blocks for images, links, HTML attributes.
    - Adds necessary imports.
    """
    print(f"  Processing: {mdx_path}")
    content = ""
    try:
        with open(mdx_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        print(f"    Error reading {mdx_path}: {e}")
        return

    admonition_import = "import {Admonition} from \"@/components/Admonition\";\n"
    tabs_import = "import { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\n"
    needs_admonition_import = False
    needs_tabs_import = False

    html_to_react_attrs = {
        'frameborder': 'frameBorder', 'allowfullscreen': 'allowFullScreen', 'tabindex': 'tabIndex',
        'readonly': 'readOnly', 'maxlength': 'maxLength', 'cellspacing': 'cellSpacing',
        'cellpadding': 'cellPadding', 'rowspan': 'rowSpan', 'colspan': 'colSpan',
        'crossorigin': 'crossOrigin', 'datetime': 'dateTime', 'for': 'htmlFor', 'class': 'className',
        'autocomplete': 'autoComplete', 'autofocus': 'autoFocus', 'enctype': 'encType',
        'formaction': 'formAction', 'hreflang': 'hrefLang', 'inputmode': 'inputMode',
        'srcdoc': 'srcDoc', 'srclang': 'srcLang', 'srcset': 'srcSet',
        'acceptcharset': 'acceptCharset', 'accesskey': 'accessKey',
        'contenteditable': 'contentEditable', 'contextmenu': 'contextMenu', 'spellcheck': 'spellCheck'
    }

    # Regex to find start of admonition (captures marker, type, optional title)
    admonition_regex = re.compile(r'^(!!!|\?\?\?|\+\+\+)\s+([a-zA-Z0-9_-]+)(?:\s+"([^"]*)")?\s*$', re.MULTILINE)
    # Regex to find start of a tab (captures title)
    tab_start_regex = re.compile(r'^=== \"(.*?)\"\s*$', re.MULTILINE)

    processed_content_parts = [] # Store processed parts (strings)
    lines = content.splitlines()
    line_idx = 0
    content_len = len(lines)

    while line_idx < content_len:
        line = lines[line_idx]
        admonition_match = admonition_regex.match(line)
        tab_match = tab_start_regex.match(line)

        # --- Handle Admonition Block ---
        if admonition_match:
            needs_admonition_import = True
            admonition_marker = admonition_match.group(1)
            admonition_type = admonition_match.group(2).lower()
            admonition_title = admonition_match.group(3) if admonition_match.group(3) is not None else admonition_type.capitalize()
            # Escape quotes in title for the attribute value
            escaped_title = admonition_title.replace('"', '\\"')

            body_lines = []
            line_idx += 1 # Move past header line
            while line_idx < content_len:
                current_line = lines[line_idx]
                indent_match = re.match(r'^( {4}|\t)', current_line)
                if indent_match or not current_line.strip(): # Indented or blank line
                    # Dedent if indented, otherwise keep as is (for blank lines)
                    dedented_line = current_line[len(indent_match.group(1)):] if indent_match else current_line
                    body_lines.append(dedented_line)
                    line_idx += 1
                else:
                    break # End of admonition block

            admonition_body = '\n'.join(body_lines)
            processed_body = process_inline_and_html(admonition_body, source_md_path, source_docs_dir, mdx_path, html_to_react_attrs)

            type_map = {
                "note": "note", "info": "info", "tip": "tip", "success": "success",
                "question": "question", "warning": "warning", "failure": "failure",
                "danger": "danger", "bug": "bug", "example": "example", "quote": "quote",
                "abstract": "abstract", "hint": "tip"
            }
            mapped_type = type_map.get(admonition_type, "note")

            admonition_component = f'<Admonition type="{mapped_type}" title="{escaped_title}">\n{processed_body}\n</Admonition>'
            processed_content_parts.append(admonition_component)

        # --- Handle Tab Block ---
        elif tab_match:
            needs_tabs_import = True
            tabs_data = []
            current_tab_title = tab_match.group(1)
            current_tab_lines = []
            line_idx += 1 # Move past the first === line

            while line_idx < content_len:
                current_line = lines[line_idx]
                next_tab_match = tab_start_regex.match(current_line)

                if next_tab_match:
                    # Finish previous tab
                    tabs_data.append({
                        'title': current_tab_title,
                        'raw_content': '\n'.join(current_tab_lines)
                    })
                    # Start new tab
                    current_tab_title = next_tab_match.group(1)
                    current_tab_lines = []
                    line_idx += 1
                else:
                    indent_match = re.match(r'^( {4}|\t)', current_line)
                    if indent_match or not current_line.strip(): # Indented or blank line
                        # Dedent if indented, otherwise keep as is (for blank lines)
                        dedented_line = current_line[len(indent_match.group(1)):] if indent_match else current_line
                        current_tab_lines.append(dedented_line)
                        line_idx += 1
                    else:
                        break # End of the entire tab block

            # Add the last tab's data
            tabs_data.append({
                'title': current_tab_title,
                'raw_content': '\n'.join(current_tab_lines)
            })

            if tabs_data:
                tabs_list_items = []
                tabs_content_items = []
                default_value = sanitize_slug(tabs_data[0]['title'])
                if not default_value: default_value = "tab-1" # Fallback default value

                for i, tab in enumerate(tabs_data):
                    title = tab['title']
                    raw_content = tab['raw_content']
                    value = sanitize_slug(title)
                    if not value: value = f"tab-{i+1}"

                    processed_tab_content = process_inline_and_html(raw_content, source_md_path, source_docs_dir, mdx_path, html_to_react_attrs)

                    # Title goes inside the trigger tag, value is the slug
                    tabs_list_items.append(f'<TabsTrigger value="{value}">{title}</TabsTrigger>')
                    tabs_content_items.append(f'<TabsContent value="{value}">\n{processed_tab_content}\n</TabsContent>')

                # Indent the generated JSX for readability
                tabs_list_str = "\n    ".join(tabs_list_items)
                tabs_content_str = "\n  ".join(tabs_content_items) # Indent content items less

                tabs_component = f'<Tabs defaultValue="{default_value}" className="w-full">\n' # Add class for width
                tabs_component += f'  <TabsList>\n    {tabs_list_str}\n  </TabsList>\n'
                tabs_component += f'  {tabs_content_str}\n'
                tabs_component += '</Tabs>'
                processed_content_parts.append(tabs_component)

        # --- Handle Regular Line / Text Segment ---
        else:
            text_segment_lines = []
            start_text_idx = line_idx
            while line_idx < content_len:
                 current_line = lines[line_idx]
                 # Check if the *current* line starts a block
                 if admonition_regex.match(current_line) or tab_start_regex.match(current_line):
                     break # Stop accumulating text
                 else:
                     text_segment_lines.append(current_line)
                     line_idx += 1

            if text_segment_lines:
                text_segment = '\n'.join(text_segment_lines)
                # Avoid processing empty segments which can happen with consecutive newlines
                if text_segment.strip():
                    processed_segment = process_inline_and_html(text_segment, source_md_path, source_docs_dir, mdx_path, html_to_react_attrs)
                    processed_content_parts.append(processed_segment)
            # If no text lines were collected but we didn't hit a block, it means we are at the end?
            # The outer loop condition `while line_idx < content_len` handles termination.

    # --- Final Assembly ---
    final_output_parts = []
    added_imports = set()

    # Check original content for existing imports before adding new ones
    has_existing_tabs_import = "from \"@/components/ui/tabs\"" in content or "from '@/components/ui/tabs'" in content
    has_existing_admonition_import = "from \"@/components/Admonition\"" in content or "from '@/components/Admonition'" in content

    if needs_tabs_import and not has_existing_tabs_import:
        import_str = tabs_import.strip()
        if import_str not in added_imports:
             final_output_parts.append(tabs_import)
             added_imports.add(import_str)
    if needs_admonition_import and not has_existing_admonition_import:
        import_str = admonition_import.strip()
        if import_str not in added_imports:
             final_output_parts.append(admonition_import)
             added_imports.add(import_str)

    if added_imports:
        final_output_parts.append("\n") # Add newline after imports

    # Join the processed parts, using double newline to separate blocks/segments
    final_output_parts.extend(processed_content_parts)
    # Filter out any potential None or empty strings from parts list before joining
    final_output = "\n\n".join(filter(None, final_output_parts)).strip() + "\n" # Ensure single trailing newline

    # Write processed content back to file
    try:
        with open(mdx_path, 'w', encoding='utf-8') as f:
            f.write(final_output)
    except Exception as e:
        print(f"    Error writing processed content to {mdx_path}: {e}")


def process_nav_item(item, current_path_parts, parent_meta_dict, source_docs_dir, dest_app_dir, redirect_rules):
    """
    Recursively processes a navigation item from mkdocs.yml.
    Generates page.mdx files, folder-specific _meta.tsx files, and collects redirect rules.
    """
    if isinstance(item, dict):
        # Should only be one key-value pair per dict item in nav
        title, value = list(item.items())[0]
        slug = sanitize_slug(title)
        if not slug: # Handle cases where title becomes empty slug
             print(f"  Warning: Skipping item with title '{title}' resulting in empty slug.")
             return

        if isinstance(value, str): # It's a page
            source_md_filename = value
            # Ensure source_md_path is relative to the SOURCE_DOCS_DIR base
            source_md_path = os.path.join(source_docs_dir, source_md_filename)
            # Destination folder path uses the slug
            dest_folder_path = os.path.join(dest_app_dir, *current_path_parts, slug)
            dest_mdx_path = os.path.join(dest_folder_path, 'page.mdx')

            print(f"Processing page: '{title}' -> {dest_folder_path}")

            if os.path.isfile(source_md_path):
                try:
                    os.makedirs(dest_folder_path, exist_ok=True)
                    # Copy first, then process the copy
                    shutil.copy2(source_md_path, dest_mdx_path)
                    # Pass the source filename relative to source_docs_dir for image path calculation
                    process_mdx_file(dest_mdx_path, source_md_filename, source_docs_dir)
                    parent_meta_dict[slug] = title

                    # --- Add Redirect Rule ---
                    source_path = '/' + source_md_filename.replace('.md', '')
                    # Ensure destination path parts are correctly joined
                    destination_path = '/' + '/'.join(current_path_parts + [slug])
                    redirect_rules.append({
                        'source': source_path,
                        'destination': destination_path,
                        'permanent': True
                    })
                    # --- End Add Redirect Rule ---

                except Exception as e:
                    print(f"  Error processing file {source_md_path}: {e}")
            else:
                print(f"  Warning: Source file not found: {source_md_path}")

        elif isinstance(value, list): # It's a sub-menu/folder
            print(f"Processing folder: '{title}' -> {os.path.join(dest_app_dir, *current_path_parts, slug)}")
            parent_meta_dict[slug] = title # Add folder entry to parent meta

            # Create meta dict for the *current* folder
            current_folder_meta = {}
            current_folder_dest_path = os.path.join(dest_app_dir, *current_path_parts, slug)
            current_meta_file_path = os.path.join(current_folder_dest_path, '_meta.tsx')
            new_path_parts = current_path_parts + [slug]

            # Ensure the destination folder exists before processing children or writing _meta.tsx
            os.makedirs(current_folder_dest_path, exist_ok=True)

            # Process children, passing the current_folder_meta and redirect_rules list
            for sub_item in value:
                process_nav_item(sub_item, new_path_parts, current_folder_meta, source_docs_dir, dest_app_dir, redirect_rules)

            # Write the _meta.tsx file for the current folder
            if current_folder_meta: # Only write if there are items
                meta_content = f"export default {format_meta_object(current_folder_meta, indent=1)}"
                try:
                    with open(current_meta_file_path, 'w', encoding='utf-8') as f:
                        f.write(meta_content)
                    print(f"  Generated meta file: {current_meta_file_path}")
                except Exception as e:
                    print(f"  Error writing meta file {current_meta_file_path}: {e}")

    elif isinstance(item, str): # Simple file entry (less common for structure)
        # Treat as a page
        source_md_filename = item
        # Generate title from filename if needed (could improve this)
        raw_title = Path(item).stem.replace('-', ' ').replace('_', ' ').title()
        slug = sanitize_slug(raw_title) # Use sanitized title for slug
        if not slug:
             print(f"  Warning: Skipping item '{item}' resulting in empty slug.")
             return
        title = raw_title # Keep original-cased title for display

        source_md_path = os.path.join(source_docs_dir, source_md_filename)
        dest_folder_path = os.path.join(dest_app_dir, *current_path_parts, slug)
        dest_mdx_path = os.path.join(dest_folder_path, 'page.mdx')

        print(f"Processing page: '{title}' (from '{item}') -> {dest_folder_path}")

        if os.path.isfile(source_md_path):
            try:
                os.makedirs(dest_folder_path, exist_ok=True)
                shutil.copy2(source_md_path, dest_mdx_path)
                # Pass the source filename relative to source_docs_dir
                process_mdx_file(dest_mdx_path, source_md_filename, source_docs_dir)
                # Add entry to the parent's meta dictionary
                parent_meta_dict[slug] = title

                # --- Add Redirect Rule ---
                source_path = '/' + source_md_filename.replace('.md', '')
                # Ensure destination path parts are correctly joined
                destination_path = '/' + '/'.join(current_path_parts + [slug])
                redirect_rules.append({
                    'source': source_path,
                    'destination': destination_path,
                    'permanent': True
                })
                # --- End Add Redirect Rule ---

            except Exception as e:
                print(f"  Error processing file {source_md_path}: {e}")
        else:
            print(f"  Warning: Source file not found: {source_md_path}")

def main():
    """Main execution function."""
    print("Starting MkDocs to Nextra migration...")

    # --- Load mkdocs.yml ---
    try:
        with open(MKDOCS_FILE, 'r', encoding='utf-8') as f:
            mkdocs_config = yaml.safe_load(f)
        print(f"Loaded '{MKDOCS_FILE}'")
    except FileNotFoundError:
        print(f"Error: '{MKDOCS_FILE}' not found in the current directory.")
        return
    except Exception as e:
        print(f"Error reading or parsing '{MKDOCS_FILE}': {e}")
        return

    nav_data = mkdocs_config.get('nav')
    if not nav_data:
        print("Error: 'nav' section not found in mkdocs.yml")
        return

    # --- Optional: Clean destination directory ---
    # Be careful enabling this!
    # if os.path.exists(DEST_APP_DIR):
    #     print(f"Cleaning destination directory: {DEST_APP_DIR}")
    #     # shutil.rmtree(DEST_APP_DIR)
    # os.makedirs(DEST_APP_DIR, exist_ok=True)

    # --- Process Navigation and Files ---
    top_level_meta = {}
    # Add the default index page (assuming you have an app/page.mdx or similar)
    # You might need to adjust this if your index isn't handled by mkdocs.yml
    top_level_meta['index'] = {
         'title': 'Home',
         'display': 'hidden' # Often hidden if it's just a landing page
    }
    # Add other top-level non-mkdocs pages if necessary, e.g.:
    # top_level_meta['other-page'] = 'Other Page Title'

    print("Processing navigation items and generating files...")
    redirect_rules = [] # Initialize list to store redirect rules

    # Process top-level items from mkdocs nav
    # The process_nav_item function will recursively handle sub-items
    # and generate _meta.tsx files in subdirectories, collecting redirects.
    for item in nav_data:
        process_nav_item(item, [], top_level_meta, SOURCE_DOCS_DIR, DEST_APP_DIR, redirect_rules)

    # --- Process existing redirects from mkdocs.yml ---
    print("Processing existing redirects from mkdocs.yml...")
    mkdocs_redirects = {}
    # Navigate safely through the config structure
    plugins = mkdocs_config.get('plugins', [])
    if isinstance(plugins, list):
        for plugin in plugins:
            if isinstance(plugin, dict) and 'redirects' in plugin:
                mkdocs_redirects = plugin['redirects'].get('redirect_maps', {})
                break
            elif isinstance(plugin, str) and plugin == 'redirects':
                # Handle case where plugin options might be elsewhere (less common)
                # This part might need adjustment based on actual mkdocs.yml structure if redirects aren't nested
                pass

    if mkdocs_redirects:
        for source, dest in mkdocs_redirects.items():
            # Basic normalization: add leading slash, remove .md
            source_path = '/' + source.replace('.md', '')
            dest_path = '/' + dest.replace('.md', '')
            # Avoid adding duplicates if source already handled by nav processing
            # Note: This simple check might not catch all nuances if paths differ slightly
            if not any(rule['source'] == source_path for rule in redirect_rules):
                 redirect_rules.append({
                     'source': source_path,
                     'destination': dest_path,
                     'permanent': True # Assume permanent for old redirects
                 })
                 print(f"  Added redirect map: {source_path} -> {dest_path}")
    else:
        print("  No 'redirect_maps' found in mkdocs.yml plugins configuration.")


    # --- Generate top-level app/_meta.tsx ---
    print("Generating top-level app/_meta.tsx...")
    meta_content = f"export default {format_meta_object(top_level_meta, indent=1)}"
    meta_file_path = os.path.join(DEST_APP_DIR, '_meta.tsx') # Note: _meta.tsx, not _meta.global.tsx

    try:
        os.makedirs(DEST_APP_DIR, exist_ok=True) # Ensure app dir exists before writing meta
        with open(meta_file_path, 'w', encoding='utf-8') as f:
            f.write(meta_content)
        print(f"Successfully generated '{meta_file_path}'")
    except Exception as e:
        print(f"Error writing '{meta_file_path}': {e}")

    # --- Generate redirects.ts file ---
    print("\nGenerating redirects.ts file...")
    redirects_file_path = 'redirects.ts'
    redirects_ts_content_parts = [
        "// Generated by migrate_mkdocs_to_nextra.py",
        "// Contains redirect rules from mkdocs.yml nav structure and explicit redirects.",
        "",
        "import type { Redirect } from 'next/dist/lib/load-custom-routes';",
        "",
        "export const migrationRedirects: Redirect[] = ["
    ]

    # Use json.dumps for proper escaping and formatting of each rule object
    for rule in redirect_rules:
        # Convert Python bool True to JS true
        rule_str = json.dumps(rule, indent=4).replace('true', 'true')
        redirects_ts_content_parts.append(rule_str + ",")

    redirects_ts_content_parts.append("];")
    redirects_ts_content = "\n".join(redirects_ts_content_parts)

    try:
        with open(redirects_file_path, 'w', encoding='utf-8') as f:
            f.write(redirects_ts_content)
        print(f"Successfully generated '{redirects_file_path}' with {len(redirect_rules)} rules.")
    except Exception as e:
        print(f"Error writing '{redirects_file_path}': {e}")


    print("\nMigration script finished.")
    print(f"Check the '{DEST_APP_DIR}' directory for generated files.")
    print("Review the generated MDX files for any formatting issues or needed manual adjustments, especially complex HTML/JSX.")

    # --- Instructions for next.config.ts ---
    print("\n--- Action Required: Update next.config.ts ---")
    print("To apply the generated redirects, modify your 'next.config.ts' file:")
    print("1. Import the generated redirects:")
    print("   import { migrationRedirects } from './redirects';")
    print("\n2. Add or modify the 'redirects' function in your NextConfig object:")
    print("""
    const nextConfig: NextConfig = {
      // ... other configurations
      async redirects() {
        // Combine generated redirects with any other custom redirects you might have
        const customRedirects = [
          // { source: '/some/other/path', destination: '/new/location', permanent: true },
        ];
        return [...migrationRedirects, ...customRedirects];
      },
      // ... rest of your config
    };
    """)
    print("-------------------------------------------------")

if __name__ == "__main__":
    # Check for PyYAML dependency
    try:
        import yaml
    except ImportError:
        print("Error: PyYAML is not installed.")
        print("Please install it using: pip install PyYAML")
        exit(1)
    main()

```

## Purpose

The primary goal is to automate the conversion of your MkDocs documentation structure and Markdown files into the file-based routing and MDX format used by Nextra. It aims to handle:

*   **Directory Structure:** Converts the `nav` section of `mkdocs.yml` into Nextra's nested directory structure within the `app/` directory.
*   **Metadata Files:** Generates `_meta.tsx` files in each directory to define the sidebar navigation order and titles based on the `mkdocs.yml` nav.
*   **Markdown to MDX Conversion:** Renames `.md` files to `page.mdx` within their respective generated folders.
*   **Component Conversion:**
    *   Converts MkDocs Admonitions (`!!! type "Title"`) into a custom `<Admonition>` React component (assuming you have one at `@/components/Admonition`).
    *   Converts MkDocs Tabbed (`=== "Title"`) into `<Tabs>` components (assuming you have Shadcn UI Tabs components at `@/components/ui/tabs`).
*   **Image Handling:** Copies image files referenced in Markdown to the corresponding Nextra page folders and updates the paths in the MDX files.
*   **HTML Attribute Conversion:** Attempts to convert common HTML attributes (like `class`, `style`, `frameborder`) to their React/JSX equivalents (`className`, `style={{...}}`, `frameBorder`).
*   **Link/HTML Cleanup:** Removes MkDocs-specific attribute lists (`{...}`) from links and converts `<br>` tags.
*   **Redirect Generation:** Creates a `redirects.ts` file containing redirect rules mapping old MkDocs paths (derived from the `nav` and the `plugins.redirects.redirect_maps` in `mkdocs.yml`) to the new Nextra paths.

## Prerequisites

*   **Python 3:** The script is written in Python 3.
*   **PyYAML:** Used for parsing the `mkdocs.yml` file. Install it if you haven't already:
    ```bash
    pip install PyYAML
    ```
*   **MkDocs Project:** An existing MkDocs project with a `mkdocs.yml` file and a `docs` directory (or as configured).
*   **Next.js/Nextra Project:** A Next.js project set up with Nextra where you want to migrate the content.

## Configuration

Before running, adjust the configuration constants at the top of the `migrate_mkdocs_to_nextra.py` script:

```python
# --- Configuration ---
MKDOCS_FILE = 'mkdocs.yml' # Path to your mkdocs configuration file
SOURCE_DOCS_DIR = './docs' # Directory containing mkdocs source .md files/folders referenced in nav
DEST_APP_DIR = 'app'       # The target directory for Nextra content (usually 'app')
IMAGE_ALT_TEXT = "ethereum-blockchain-developer-image" # Default alt text for images missing it
# --- End Configuration ---
```

## Usage

1.  Place the `migrate_mkdocs_to_nextra.py` script in the root of your MkDocs project directory (the same directory where `mkdocs.yml` resides).
2.  Ensure the configuration constants in the script are set correctly for your project structure.
3.  Run the script from your terminal:

    ```bash
    python migrate_mkdocs_to_nextra.py
    ```

4.  The script will:
    *   Read `mkdocs.yml`.
    *   Create the `app/` directory structure based on the `nav`.
    *   Copy and process `.md` files into `app/.../page.mdx`.
    *   Copy referenced image files.
    *   Generate `_meta.tsx` files in each directory.
    *   Generate a `redirects.ts` file in the root directory.
    *   Print progress, warnings, and errors to the console.

## Output

*   **`app/` directory:** Contains the migrated content structured for Nextra's file-based routing.
    *   Each navigable item from `mkdocs.yml` becomes a folder (e.g., `app/getting-started/`).
    *   Markdown files are placed inside their corresponding folder as `page.mdx` (e.g., `app/getting-started/introduction/page.mdx`).
    *   Images are copied into subdirectories within the page folders (e.g., `app/getting-started/introduction/images/screenshot.png`).
*   **`_meta.tsx` files:** Located in each generated folder within `app/`, defining the navigation order and titles for Nextra's sidebar.
*   **`redirects.ts` file:** Created in the project root. Contains an array of redirect objects mapping old MkDocs URLs to the new Nextra URLs.

## Post-Migration Steps

1.  **Review MDX Files:** Carefully review the generated `page.mdx` files. While the script handles common cases, complex Markdown, HTML, or embedded scripts might require manual adjustments to work correctly in MDX/React. Pay special attention to:
    *   Inline HTML/JSX conversion.
    *   Escaped characters (`<`, `{`, etc.).
    *   Image paths and alt text.
    *   Admonition and Tabs component props.
2.  **Implement React Components:** Ensure you have the necessary React components (`Admonition`, `Tabs`, `TabsList`, `TabsTrigger`, `TabsContent`) available in your Next.js project at the paths expected by the script's imports (`@/components/...`). You might need to create or adapt these components.
3.  **Configure Redirects:** Follow the instructions printed by the script at the end of its execution to integrate the generated `redirects.ts` file into your `next.config.ts` (or `next.config.mjs`). This is crucial for preserving SEO and preventing broken links.
    *   Import `migrationRedirects` from `./redirects`.
    *   Add or modify the `redirects` async function in your `next.config.ts` to return the `migrationRedirects` array (potentially combined with other custom redirects).
4.  **Install Dependencies:** If the script converted elements that require specific React libraries (like UI components), make sure those libraries are installed in your Next.js project.
5.  **Test Thoroughly:** Run your Next.js development server (`npm run dev` or `yarn dev`) and thoroughly test the migrated site, checking navigation, page rendering, component behavior, images, and links.

## Limitations

*   **Complex HTML/JavaScript:** The script performs basic HTML attribute conversion but may struggle with complex embedded HTML structures or JavaScript within Markdown. These often require manual conversion to JSX or React components.
*   **MkDocs Plugins:** It only explicitly handles `admonition`, `pymdownx.tabbed`, and `redirects`. Content generated or modified by other MkDocs plugins or Markdown extensions might not be converted correctly.
*   **Theme-Specific Features:** Features specific to the MkDocs Material theme (beyond admonitions and tabs) are not converted.
*   **Slug Generation:** Slug generation is basic (lowercase, replaces spaces with hyphens, removes special characters). Titles that result in empty or conflicting slugs might cause issues.
*   **Internal Links:** While relative image paths are handled, the script doesn't currently rewrite internal Markdown links (`[link text](other-page.md)`) to match the new Nextra routing structure. These may need manual updates.

## Example

**`mkdocs.yml` (nav section):**

```yaml
nav:
  - "Home": "index.md"
  - "Getting Started":
      - "Introduction": "start/intro.md"
      - "Installation": "start/install.md"
  - "Advanced":
      - "Configuration": "advanced/config.md"
```

**Resulting `app/` structure:**

```
app/
├── page.tsx # (Your existing root page)
├── _meta.tsx
├── getting-started/
│   ├── introduction/
│   │   └── page.mdx  # Content from docs/start/intro.md
│   ├── installation/
│   │   └── page.mdx  # Content from docs/start/install.md
│   └── _meta.tsx
└── advanced/
    ├── configuration/
    │   └── page.mdx  # Content from docs/advanced/config.md
    └── _meta.tsx
```

**`app/_meta.tsx`:**

```typescript
export default {
  "index": { "title": "Home", "display": "hidden" },
  "getting-started": "Getting Started",
  "advanced": "Advanced"
}
```

**`app/getting-started/_meta.tsx`:**

```typescript
export default {
  "introduction": "Introduction",
  "installation": "Installation"
}
```

**`redirects.ts` (excerpt):**

```typescript
// Generated by migrate_mkdocs_to_nextra.py
// ...
export const migrationRedirects: Redirect[] = [
    {
        "source": "/start/intro",
        "destination": "/getting-started/introduction",
        "permanent": true
    },
    {
        "source": "/start/install",
        "destination": "/getting-started/installation",
        "permanent": true
    },
    {
        "source": "/advanced/config",
        "destination": "/advanced/configuration",
        "permanent": true
    },
    // ... potentially more redirects from redirect_maps plugin ...
];
```
